# CAOS_cheatsheet

## Лекция 2 (05/11/2021)

Разберемся с тем, как у нас работает память 

Пусть у нас есть куча ячеек памяти:

| 0x40000 |   |   |   |   | 0x40004 |   |   |   |   | 0x40008 |   |   |   |   | 0x4000c |   |   |   |   |
|---------|---|---|---|---|---------|---|---|---|---|---------|---|---|---|---|---------|---|---|---|---|

Пусть `eax = 0xdeadbeef`. Тогда после команды `mov %eax, 0x40000`

| 0x40000 | ef  | be  |  ad | de  | 0x40004 |   |   |   |   | 0x40008 |   |   |   |   | 0x4000c |   |   |   |   |
|---------|---|---|---|---|---------|---|---|---|---|---------|---|---|---|---|---------|---|---|---|---|

Работаем с одним байтом: 
```asm
movzb 0x40000, %ebx  # заполнить нулями
movsb 0x40000, %ecx  # заполнить знаковым битом
```
После этого:
```asm
ebx = 0x000000ef
ecx = 0xffffffef
```

#### Попробуем разобраться, как ассемблер может помочь работать с адресами
```asm
.global main

main:
	mov x, %eax
	call writei32
	call finish
x:
	.int 42  # директива, которая в следующие 4 байта кладет число
``` 

*Замечание.* В одной команде нельзя дважды в качестве аргументов указывать адрес памяти.

*Замечание.* Нехорошо писать `mov %eax, y`: операционная система следит, чтобы в код программы ничего нельзя было писать.

Как это можно исправить?

```asm
.text
.global main

main:
	mov x, %eax  # direct addressing 
	add y, %eax
	mov %eax, y
	call writei32
	call finish

.data  # директива, которая переносит переменные в отдельную секцию, в которой можно писать
x:
	.int 42  # т.е. тут мы говорим: в текущую секцию (это .data) запиши, 
			 # что численное значение следующих 4 байтов -- это 42
y:
	.int 31337
``` 

#### А если хотим выделить больше байтов?
Выделять 4 байта не очень удобно. Поэтому есть функция `.skip 1024, 1`, которая выделяет 1024 следующих байта и иницилизирует их, например, единицами (by default значение 0). Можно воспринимать это как массив.

Программа, где мы читаем данные из массива:
```asm
.text
.global main

main:
	call readi32
	mov %eax, %ebx
	call readi32

	# y[ebx] = eax
	# вычисляем адрес, а потом обращаемся с помощью mov
	mov $y, %edi  # в edi теперь адрес на начало массива
	shl $2, %ebx  # умножаем на 4, т. к. каждый элемент массива занимает 4 байта
	add %ebx, $edi 
	mov %eax, (%edi)  # Скобки вокруг %edi означают, что мы 
					  # пересылаем данные из регистра в память по адресу, 
					  # который лежит в регистре

	call writei32
	call finish

.data  
y:
	.skip 800  # 200 машинных слов, по сути int y[200]
``` 

То же самое, что выше, можно записать ещё и так:
```asm
.text
.global main

main:
	call readi32
	mov %eax, %ebx
	call readi32

	# y[ebx] = eax

	# вычисляем адрес, а потом обращаемся с помощью mov
	mov $y, %edi 
	mov (%edi, %ebx, 4), %eax
	# (r1, r2, 2**i) -> r1 + r2 * 2**i

	# or 

	mov y(, %ebx, 4), %eax
	# offset(r1, r2, 2**i) -> offset + r1 + r2 * 2**i

	call writei32
	call finish

.data  
y:
	.skip 800  # 200 машинных слов, по сути int y[200]
``` 


#### Хотим работать со структурами данных

```asm
.data  
person:
	.int 180  # height
	.int 80   # weight
``` 
Тогда первое поле (его рост) -- это просто данные по адресу структуры, а второе поле (вес) -- адрес структуры + 4

Заведем массив человеков (структур):
```asm
.data  
persons:
	.int 180  # height
	.int 80   # weight
	.int 150
	.int 90
	.skip 400  # ещё 50 человек
``` 

Тогда читать %ebx-го человека:
```asm
	mov persons(, %ebx, 8), %eax  # height
	mov persons+4(, %ebx, 8), %eax  # weight
```

#### Односвязный список

Считываем список, пока не появится 0, потом печатаем его  в обратном порядке:
В нашей структуре хранится число и адрес следующего элемента.
```asm
.global main
main:
	xor %edi, %edi  # head
	mov $list_storage, %esi  # в esi адрес следующего незанятого элемента массива

readloop:
	call readi32
	test %eax, %eax  # немодицифирующий and, который только устанавливает флаги
					 # по сути проверка, что %eax -- ноль
	jz writeloop
	mov %eax, (%esi)  # кладем число в следующий свободный элемент
	mov %edi, 4(%esi)  # в указатель кладем текущую голову списка
	mov %esi, %edi
	add $8, %esi  # сохраняем инвариант, что esi -- следующий свободный элемент
	jmp readloop

writeloop:
	test %edi, %edi  
	jz end
	mov (%edi), %eax
	call writei32
	mov 4(%edi), %edi
	jmp writeloop

end:
	call finish

.data
	# [ data ][ next ]
list_storage:
	.skip 1024  # выделили кучу памяти
```



#### А если мы хотим вызывать программу из разных мест?

Научимся перескакивать на метку, которую задали:
```asm
.global main

double_eax:
	add %eax, %eax
	jmp *%edx  # переходим на метку, заданную в регистре 

main:
	# something
	mov $return, %edx
	jmp double_eax

return:
	# something
	jmp next

next:
	# something
	mov $ret2, %edx
	jmp double_eax

ret2:
	# something
```

#### Функции (подпрограммы)

Операционная система гарантирует нам, что у нас есть огромный массив, который называется *стеком* и на первый занятый элемент в нем указывает специальный регистр `esp`. Причем стек растет вниз.

Чтобы записать число в стек:
```asm
	sub $4, %esp   # сдвигаем на длину машинного слова
	mov $43, (%esp)
```

Таким образом написанное выше можно записать так:
```asm
.global main

double_eax:
	add %eax, %eax
	mov (%esp), %double_eax
	add $4, %esp
	jmp *%edx

main:
	# something
	sub $4, %esp
	movl $return, (%esp)  # movl -- чтобы уточнить, что нам надо переслать 4 байта
	jmp double_eax

return:
	# something
```

Обратим внимание на специальные инструкции:
```asm
push rm  # уменьшить esp на 4 и положить туда, что мы передали в качестве аргумента 
push %eax  # same as: sub $4, %esp ; mov %eax, (%esp)


pop rm  # удаляет значение из стека
pop %eax  # same as: mov (%esp), %eax ; add $4, %esp 


call addr  # push $return ; jmp addressing
		   # [         return xxxxxxxxxx]
		   #           ^esp

ret  # pop %eip
		   # [         xxxxxxxxxx]
		   #           ^esp
```


Тогда наша программа становится: 

```asm
.global main

double_eax:
	add %eax, %eax
	ret

main:
	# something
	call double_eax

return:
	# something
```

#### Локальные переменные

Выделим память на стеке как два машинных слова:
```asm
double_eax:
	sub $8, %esp 
		   # [         A   B  xxxxxxxxxx]
		   #           ^esp
	# int A;   # mov (%esp), %eax
	# int B;   # mov 4(%esp), %eax
	add %eax, %eax


	add $8, %esp  # важно! очищаем стек: удаляем локальные переменные
	ret 
```

Однако, конечно, это не очень удобно: если забыть очистить стек, то `ret` воспримет адрес переменной как адрес возврата, скопировала бы её в `eip` и UB.

Поэтому существует специальный регистр: `%ebp`

```asm
double_eax:
	push %ebp   # [       old_ebp  return]
	mov %esp, %ebp


	sub $8, %esp 
		   # [         A   B   old_ebp  return xxxxxxxxxx]
		   #           ^esp    ^ebp
	# int A;   # mov -8(%ebp), %eax
	# int B;   # mov -4(%ebp), %eax
	add %eax, %eax


	mov %ebp, %esp  # стёрли локальные переменные
	pop %ebp  # теперь eps показывает на return (адрес возврата)
	ret  # стандартный эпилог функции
```

Есть сокращение:
```asm
	mov %ebp, %esp 
	pop %ebp  

	# OR

	leave
```

**Краткий Q&A**

- *Почему мы не использовали `%esp` для обращения к переменным?* Потому что относительно `ebp` смещение к локальным переменным фиксировано, а наш предыдущий регистр `esp` мог двигаться.

- *В чем смысл адреса возврата в стеке?* Без него мы не знаем, куда возвращаться из подпрограммы.

- *Зачем делать `push` и `pop` для `ebp`?* Поскольку каждая подпрограмма использует `ebp`, то мы приходим к cdecl-соглашению: 
	1. Подпрограмма сохраняет (не будет модифицировать) регистры `%ebp, %ebx, %esi, %edi, %esp` (они ещё называются callee-saved). 
	2. Можно испортить: `%eax, %ecx, %edx` (caller-saved). 
	3. Возвращаемое значение подпрограмма кладет в `%eax`.

Достаточно стандартная идиома: если мы хотим сохранить значение регистра, надо его записать в стек.


#### Как передавать в функцию аргументы?

Пусть у нас есть какая-то функция `foo` с двумя аргументами.

```asm

# int foo(int a, int b);  [     old_ebp  return    a   b    xxxx]
#							 	^ ebp

# Тогда доступ к переменным: mov 8(%ebp), %edi
# Ожидается, что функция знает, сколько у нее параметров

push b
push a
call foo 
add $8, %esp
```


### Что вообще проходит, когда мы запускаем программу?

Так как мы пишем код с расширением .S, то вызывается препроцессор языка C. Что он умеет делать?

1. Обрабатывать директивы (#include, #if) и текстовые макропостановки (#define)
2. Убирать комментарии

Препроцессор создает файт с расширением .s  -- тоже ассемблерный файл, но который не требует препроцессинга. После этого запускается ассемблер, который берет исходник и делает бинарное представление текстовых команд (создает объектный файл).

После этого мы собираем объектные файлы с помощью компоновщика/линтера/специальной программой, которая превращает объектный файл в исполняемый.

Посмотреть на результат препроцессинга (program.S --> program.s):
```bash
gcc -E program.S -o program.s
```

Получить объектный файл (program.s --> program.o):
```bash
gcc -c program.s
```

Далее на лекции мы с интересом смотрели внутрь каждого файла (пытливым читателям конспектов предлагается это сделать самостоятельно при большом желании).

```bash
objdump -h program.o
objdump -h program.o | less
```

**Объяснение символов внутри после выполнения команды**
```bash
nm program.o
```

1. `T name` — в объектном файле определен символ *name*, и все могут его использовать
2. `U name` — объектному файлу требуется символ *name*; чтобы успешно скомпоновать объектный файл в исполняемый бинарник, нам потребуется, чтобы в каком-то другом объектном файле такой символ был
3. `t name` — слабый символ, пока не обращаем внимания