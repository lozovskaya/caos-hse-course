# CAOS_cheatsheet

## Лекция 3 (12/11/2021)

### Учимся читать документацию

На примере новой инструкции `LEA` попробуем распарсить, что она делает -- https://www.felixcloutier.com/x86/lea

```asm
LEA r32, m   # первый аргумент -- 32битный регистр, второй -- адрес в памяти
```

В секции Description: 

> Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand)

Делаем поправку на то, что тут используется intel-синтаксис: т.е. в нашем случае аргументы будут в другом порядке.

#### Эффективный адрес (the effective address)

Пусть у нас определен какой-то массив из машинных слов. Пусть в `ecx` лежит какой-то индекс, мы хотим обратиться к соотвествующему элементу массива и положить туда значение из `eax`. 

```asm
    mov $42, %ecx
    mov %eax, array(, %ecx, 4)  # array + ecx*4

    .data
array:  # по адресу array лежит нулевой элемент массива
    .skip 400
```

Все эти вычисления можно сделать следующим образом:

```asm
    lea array(, %ecx, 4), %ebx

    .data
array:  # по адресу array лежит нулевой элемент массива
    .skip 400
```

Процессор вычислит так называемый действительный адрес (`array + %ecx * 4`), то есть адрес `%ecx`-го элемента массива и положит это число (номер ячейки памяти) в регистр `%ebx`

Пытливым читателям предлагается посмотреть на объектный файл и увидеть там непосредственное смещение.

Помним, что метки -- просто адрес в памяти следующей инструкции.

- *Чем же lea отличается от mov?* 
```asm
    lea array(, %ecx, 4), %ebx  # ebx <- array + ecx*4
    # вычислили действительный адрес и в память не обратились

    mov %eax, array(, %ecx, 4)  # ebx <- 4 bytes from [array + ecx*4]
```

#### Инструкции деления и умножения

- [`IMUL`](https://www.felixcloutier.com/x86/imul) -- знаковое умножение

    Например, одна из форм инструкции берет значение в `eax`, умножает его на аргумент и результат кладет в 64битный `edx:eax`

- [`MUL`](https://www.felixcloutier.com/x86/mul) -- беззнаковое умножение

- [`IDIV`](https://www.felixcloutier.com/x86/idiv) -- знаковое деление

- [`DIV`](https://www.felixcloutier.com/x86/div) -- беззнаковое деление

С подробностями инструкций предлагается разобраться самостоятельно.


#### Регистры

В командах регистры кодируются какими-то короткими числами: у каждого регистра есть своей номер, который и подставляется в команду. Конечно, можно сказать, что это и есть адрес регистра, но это адрес не в общей памяти (которая имеет 32-разрядный адрес).

Можно сказать, что регистры — отдельное маленькое адресное пространство, в нем у каждого регистра есть свой номер (адрес), но обычно так не говорят: о каждом говорят по отдельности. Когда говорят о адрес, имеют в виду адреса в оперативной памяти

### Представление данных в памяти

Пусть мы положили в память какой-то число в массив

```asm
    movl $0xbad1dea, array

    .data
array:
    # 0xea  0x1d  0xad  0x0b  0x00 ...  <- вот так число положилось
    # 0     1     2     3               <- смещение
    .skip 400
```

На более старших местах в памяти лежат более старшие разряды числа.

*Замечание.* Если мы напишем просто mov, то ассемблеру непонятно, сколько байт ему передать:
    ```asm
        movb $0xea, array  # 1 байт
        movw $0x1dea, array  # 2 байта
        movl $0xbad1dea # 4 байта
    ```


Итого у нас вот такая программа:
```asm
    .global main
main:
    mov $42, %exc
    lea array(, %ecx, 4), %ebx  # array + ecx*4
    movl $0xbad1dea, array

    .data
array:
    # 0xea  0x1d  0xad  0x0b  0x00 ...  <- вот так число положилось
    # 0     1     2     3               <- смещение
    .skip 400
```

Прежде чем пересылать данные, нужно договориться о том, как эти данные выглядят внутри.

Посмотрим на исполняемый файл:
```bash
hexdump -C program | less
```

Там можно заметить, что чтобы его как-то прочитать, надо знать его структуру.

*Бинарные форматы представления данных* -- это когда: 
1. Есть чёткая внутренняя структура
2. Встречаются совершенно любые значения байт
3. Есть четкие смещения элементов этого файла друг относительно друга


*Тестовые форматы*:

1. Мало байт со значениями меньше 32 друг
2. Нет внутренней структуры, которая основа на внутреннем расположении байт
3. Специальные символы: `20` — пробел, `0a` — перевод строки и т. д.

Этот файл состоит из байт, каждый байт ассоциируем с числом, но, как нетрудно заметить, каждый байт мы сопоставляем какому-то символу.
Представление символов в виде чисел стандартизировано — `ASCII`.

Поглядеть подробности можно так (и узнать, например, что первые 32 символа -- байты 00-1F -- кодируют какие-то специальные символы, которые неочевидно как прочитать):
```bash
man ascii
```

Конвенция: *текстовый файл* — это последовательность строк, каждая строка заканчивается символом перевода строки, включая последнюю строку, но после последнего перевода строки в файле не возникает новой строчки.

### Как записать текстовые данные на языке ассемблера?

Пусть мы хотим в переменную `greeting` текстовые данные 

```asm
    .data
greeting:
    .byte 'H'  # эквивалетно директиве .byte 0x48
    .byte 'e'
    .byte 'l'
    .byte 'l'
    .byte 'o'
```

Но так писать не очень удобно, поэтому ассемблер позволяет сделать так:
```asm
    .data
greeting:
    .ascii "Hello, world!"
```
В результае этого, ассемблер берет нашу строчку и каждый ее символ кладет отдельным байтом в результирующий бинарник.

### А как записать то, что не помещается в английский алфавит?

Для этого у нас есть стандарт `unicode`, эдакий общий реестр символов. Так записаны все символы всех языков и каждому приписывается свой номер.

Поиграться:
```asm
man unicode
```

#### Как представлять эти символы в текстовом файле?

Для этого можно придумывать разные схемы.

1. Простейшее, что может прийти в голову: каждый символ юникода запишем 4мя байтами. Такое представление называет `UTF-32-LE`. Формат не очень экономный: например, в английском файле большая часть файла будет из нулевых байт состоять
2. Есть ещё `UTF-16`
3. Нам интересна в большей степени `UTF-8`.

#### UTF-8
Работает она так: есть символ есть в ascii, то он кодируется как ascii (для него достаточно 7 байт). А если он вылезает из ascii, то кодируем посложнее:

Рассмотрим, например, символ 'й', он кодируется двумя байтами:
```python
>>> 'й'.encode("utf-8")
b'\xd0\xb9'
>>> bin(0xd0) 
'0b11010000'
>>> bin(0xb9)
'0b10111001'
```

Если в закодированном тексте мы встречаем: `0b110.....`, то это значит, что наше число кодируется 2 байтами, причем следующий начинается с `0b10......`. Соотвественно, если мы возьмем символы, которые вместо точек, и запишем их подряд, то у нас получится код символа:

В случае 'й':
```
0b11010000
0b10111001
-> 

0b110 10000
0b10 111001
->
10000 111001 -> 0b10000111001
``` 

```python
>>> ord('й')
1081
>>> 0b10000111001
1081
```

Таким образом мы получили (5 + 6) 11 значащих бит.

Дальше, например, если мы встречаем байт, который начинается `0b1110....`, это значит, что символ закодирован тремя байтами, остальные начинаются с `0b10......` и `0b10......`, тут уже (4 + 6\*2)16 значащих бит.

Может быть и такое, что мы встречаем байт, который начинается `0b11110...`, это значит, что символ закодирован тремя байтами, остальные начинаются с `0b10......`, `0b10......` и `0b10......`, тут уже (3 + 6\*3) 21 значащих бит.


Преимущества такой кодировки:

- Мы сохраняем ASCII
- Для не ASCII мы используем символы, у которых единичка в старшем разряде
- он самосихронизирующийся: понятно, мы находимся в середине символа или в начале. Поэтому можно начинать с любого места и потерять максимум 1 символ.

### Что мы сейчас умеем?

1. Мы умеем делать исполняемые файлы, то есть заставлять процессор выполнять инструкции, которые мы ему написали.
    ОС копирует содержимое файлов в память, инициализирует процессор, а процессор начинает выполнять инструкции по адресу, который ему сказали. ОС загружает соответствующий адрес в регистр %eip и процесс идет.

2. Мы умеем класть данные в память
    Т.е. реквестим ОС зарезервировать кусок памяти прямо в исполняемом файле, а потос с ним работает

3. Мы умеем работать со стеком
    ОС выдает нам какой-то стек в области памяти, инициализирует соответствующим образом регистр stack pointer

Но мы пока никак не можем взаимодействовать со внешним миром, у нас есть только процессор и память и больше ничего.

Мы можем влиять на состояние процессора, влиять на состояние памяти, но не можем общаться с внешним миром.

#### Научимся завершать программы.
До этого мы использовали волшебную функцию `call finish` из внешней библиотеки, а сейчас хотим напрямую.

Изнутри мы сделать это не можем, так как процессор будет исполнять все, что ему попадется, до бесконечности или до возникновения ошибки, так что все вопросы к ОС 

Все системные вызовы перечислены в специальном заголовочном файле (у нас `unistd_32.h`)

Например, первый системный вызов, который нас интересует, это выход: можно запомнить, что он имеет номер 1 или пользоваться заголовочным файлом напрямею

Научимся писать программу, которая будет завершаться с некоторым кодом возврата
```asm
    .global main
main:
    mov $1, %eax  # номер системного вызова
    mov $3, %ebx  # первый параметр системного вызова
    # ecx -- был бы вторым параметром
    # edx -- третьим
    int $0x80  # программное прерывание, обращающееся к ОС, воспринимаем пока как магию
``` 
Теперь наша программа обращается к системного вызову номер 1, то есть exit и завершается с кодом возврата 3:
```bash
>>> ./program
>>> echo $?
3
```

Посмотреть, какие параметры у нас есть можно во второй секции:
```bash
man 2 exit
```

