# CAOS_cheatsheet

## Лекция 3 (12/11/2021)

### Учимся читать документацию

На примере новой инструкции `LEA` попробуем распарсить, что она делает -- https://www.felixcloutier.com/x86/lea

```asm
LEA r32, m   # первый аргумент -- 32битный регистр, второй -- адрес в памяти
```

В секции Description: 

> Computes the effective address of the second operand (the source operand) and stores it in the first operand (destination operand)

Делаем поправку на то, что тут используется intel-синтаксис: т.е. в нашем случае аргументы будут в другом порядке.

#### Эффективный адрес (the effective address)

Пусть у нас определен какой-то массив из машинных слов. Пусть в `ecx` лежит какой-то индекс, мы хотим обратиться к соотвествующему элементу массива и положить туда значение из `eax`. 

```asm
    mov $42, %ecx
    mov %eax, array(, %ecx, 4)  # array + ecx*4

    .data
array:  # по адресу array лежит нулевой элемент массива
    .skip 400
```

Все эти вычисления можно сделать следующим образом:

```asm
    lea array(, %ecx, 4), %ebx

    .data
array:  # по адресу array лежит нулевой элемент массива
    .skip 400
```

Процессор вычислит так называемый действительный адрес (`array + %ecx * 4`), то есть адрес `%ecx`-го элемента массива и положит это число (номер ячейки памяти) в регистр `%ebx`

Пытливым читателям предлагается посмотреть на объектный файл и увидеть там непосредственное смещение.

Помним, что метки -- просто адрес в памяти следующей инструкции.

- *Чем же lea отличается от mov?* 
```asm
    lea array(, %ecx, 4), %ebx  # ebx <- array + ecx*4
    # вычислили действительный адрес и в память не обратились

    mov %eax, array(, %ecx, 4)  # ebx <- 4 bytes from [array + ecx*4]
```

#### Инструкции деления и умножения

- [`IMUL`](https://www.felixcloutier.com/x86/imul) -- знаковое умножение

    Например, одна из форм инструкции берет значение в `eax`, умножает его на аргумент и результат кладет в 64битный `edx:eax`

- [`MUL`](https://www.felixcloutier.com/x86/mul) -- беззнаковое умножение

- [`IDIV`](https://www.felixcloutier.com/x86/idiv) -- знаковое деление

- [`DIV`](https://www.felixcloutier.com/x86/div) -- беззнаковое деление

С подробностями инструкций предлагается разобраться самостоятельно.


#### Регистры

В командах регистры кодируются какими-то короткими числами: у каждого регистра есть своей номер, который и подставляется в команду. Конечно, можно сказать, что это и есть адрес регистра, но это адрес не в общей памяти (которая имеет 32-разрядный адрес).

Можно сказать, что регистры — отдельное маленькое адресное пространство, в нем у каждого регистра есть свой номер (адрес), но обычно так не говорят: о каждом говорят по отдельности. Когда говорят о адрес, имеют в виду адреса в оперативной памяти

### Представление данных в памяти

Пусть мы положили в память какой-то число в массив

```asm
    movl $0xbad1dea, array

    .data
array:
    # 0xea  0x1d  0xad  0x0b  0x00 ...  <- вот так число положилось
    # 0     1     2     3               <- смещение
    .skip 400
```

На более старших местах в памяти лежат более старшие разряды числа.

*Замечание.* Если мы напишем просто mov, то ассемблеру непонятно, сколько байт ему передать:
    ```asm
        movb $0xea, array  # 1 байт
        movw $0x1dea, array  # 2 байта
        movl $0xbad1dea # 4 байта
    ```


Итого у нас вот такая программа:
```asm
    .global main
main:
    mov $42, %exc
    lea array(, %ecx, 4), %ebx  # array + ecx*4
    movl $0xbad1dea, array

    .data
array:
    # 0xea  0x1d  0xad  0x0b  0x00 ...  <- вот так число положилось
    # 0     1     2     3               <- смещение
    .skip 400
```

Прежде чем пересылать данные, нужно договориться о том, как эти данные выглядят внутри.

Посмотрим на исполняемый файл:
```bash
hexdump -C program | less
```

Там можно заметить, что чтобы его как-то прочитать, надо знать его структуру.

*Бинарные форматы представления данных* -- это когда: 
1. Есть чёткая внутренняя структура
2. Встречаются совершенно любые значения байт
3. Есть четкие смещения элементов этого файла друг относительно друга


*Тестовые форматы*:

1. Мало байт со значениями меньше 32 друг
2. Нет внутренней структуры, которая основа на внутреннем расположении байт
3. Специальные символы: `20` — пробел, `0a` — перевод строки и т. д.

Этот файл состоит из байт, каждый байт ассоциируем с числом, но, как нетрудно заметить, каждый байт мы сопоставляем какому-то символу.
Представление символов в виде чисел стандартизировано — `ASCII`.

Поглядеть подробности можно так (и узнать, например, что первые 32 символа -- байты 00-1F -- кодируют какие-то специальные символы, которые неочевидно как прочитать):
```bash
man ascii
```

Конвенция: *текстовый файл* — это последовательность строк, каждая строка заканчивается символом перевода строки, включая последнюю строку, но после последнего перевода строки в файле не возникает новой строчки.

### Как записать текстовые данные на языке ассемблера?

Пусть мы хотим в переменную `greeting` текстовые данные 

```asm
    .data
greeting:
    .byte 'H'  # эквивалетно директиве .byte 0x48
    .byte 'e'
    .byte 'l'
    .byte 'l'
    .byte 'o'
```

Но так писать не очень удобно, поэтому ассемблер позволяет сделать так:
```asm
    .data
greeting:
    .ascii "Hello, world!"
```
В результае этого, ассемблер берет нашу строчку и каждый ее символ кладет отдельным байтом в результирующий бинарник.

### А как записать то, что не помещается в английский алфавит?

Для этого у нас есть стандарт `unicode`, эдакий общий реестр символов. Так записаны все символы всех языков и каждому приписывается свой номер.

Поиграться:
```asm
man unicode
```

#### Как представлять эти символы в текстовом файле?

Для этого можно придумывать разные схемы.

1. Простейшее, что может прийти в голову: каждый символ юникода запишем 4мя байтами. Такое представление называет `UTF-32-LE`. Формат не очень экономный: например, в английском файле большая часть файла будет из нулевых байт состоять
2. Есть ещё `UTF-16`
3. Нам интересна в большей степени `UTF-8`.

#### UTF-8
Работает она так: есть символ есть в ascii, то он кодируется как ascii (для него достаточно 7 байт). А если он вылезает из ascii, то кодируем посложнее:

Рассмотрим, например, символ 'й', он кодируется двумя байтами:
```python
>>> 'й'.encode("utf-8")
b'\xd0\xb9'
>>> bin(0xd0) 
'0b11010000'
>>> bin(0xb9)
'0b10111001'
```

Если в закодированном тексте мы встречаем: `0b110.....`, то это значит, что наше число кодируется 2 байтами, причем следующий начинается с `0b10......`. Соотвественно, если мы возьмем символы, которые вместо точек, и запишем их подряд, то у нас получится код символа:

В случае 'й':
```
0b11010000
0b10111001
-> 

0b110 10000
0b10 111001
->
10000 111001 -> 0b10000111001
``` 

```python
>>> ord('й')
1081
>>> 0b10000111001
1081
```

Таким образом мы получили (5 + 6) 11 значащих бит.

Дальше, например, если мы встречаем байт, который начинается `0b1110....`, это значит, что символ закодирован тремя байтами, остальные начинаются с `0b10......` и `0b10......`, тут уже (4 + 6\*2)16 значащих бит.

Может быть и такое, что мы встречаем байт, который начинается `0b11110...`, это значит, что символ закодирован тремя байтами, остальные начинаются с `0b10......`, `0b10......` и `0b10......`, тут уже (3 + 6\*3) 21 значащих бит.


Преимущества такой кодировки:

- Мы сохраняем ASCII
- Для не ASCII мы используем символы, у которых единичка в старшем разряде
- он самосихронизирующийся: понятно, мы находимся в середине символа или в начале. Поэтому можно начинать с любого места и потерять максимум 1 символ.

### Что мы сейчас умеем?

1. Мы умеем делать исполняемые файлы, то есть заставлять процессор выполнять инструкции, которые мы ему написали.
    ОС копирует содержимое файлов в память, инициализирует процессор, а процессор начинает выполнять инструкции по адресу, который ему сказали. ОС загружает соответствующий адрес в регистр %eip и процесс идет.

2. Мы умеем класть данные в память
    Т.е. реквестим ОС зарезервировать кусок памяти прямо в исполняемом файле, а потос с ним работает

3. Мы умеем работать со стеком
    ОС выдает нам какой-то стек в области памяти, инициализирует соответствующим образом регистр stack pointer

Но мы пока никак не можем взаимодействовать со внешним миром, у нас есть только процессор и память и больше ничего.

Мы можем влиять на состояние процессора, влиять на состояние памяти, но не можем общаться с внешним миром.

#### 1) Научимся завершать программы.
До этого мы использовали волшебную функцию `call finish` из внешней библиотеки, а сейчас хотим напрямую.

Изнутри мы сделать это не можем, так как процессор будет исполнять все, что ему попадется, до бесконечности или до возникновения ошибки, так что все вопросы к ОС 

Все системные вызовы перечислены в специальном заголовочном файле (у нас `unistd_32.h`)

Например, первый системный вызов, который нас интересует, это выход: можно запомнить, что он имеет номер 1 или пользоваться заголовочным файлом напрямею

Научимся писать программу, которая будет завершаться с некоторым кодом возврата
```asm
    .global main
main:
    mov $1, %eax  # номер системного вызова
    mov $3, %ebx  # первый параметр системного вызова
    # ecx -- был бы вторым параметром
    # edx -- третьим
    int $0x80  # программное прерывание, обращающееся к ОС, воспринимаем пока как магию
``` 
Теперь наша программа обращается к системного вызову номер 1, то есть exit и завершается с кодом возврата 3:
```bash
>>> ./program
>>> echo $?
3
```

Посмотреть, какие параметры у нас есть можно во второй секции:
```bash
man 2 exit
```

Ещё можно сделать так:
```asm
    .global main
main:
    .equ SYS_exit, 1
    # .equ -- директива ассемблера; 
    # если бы мы написали define, то эту строчку обработал бы уже препроцессор, можно и так, но не по канону
    mov $SYS_exit, %eax
    mov $3, %ebx  
    int $0x80 
```

Посмотрим на наш исполняемый файл через `strace` -- это штука отслеживает все системные вызовы.
```bash
    strace ./program
```

#### 2) Чтение и вывод 

Файлы: просто некотоырй объект, откуда можно читать байты и куда можно записывать их

Можно представлять как некоторую машину Тьюринга.

Мы обратились к файлу и некоторый указатель указывает на начало:
```
[ ab ef 03 02 ef  ...]
  ^   <- счётчик чтения
```
Прочитали три байта:
```
[ ab ef 03 02 ef  ...]
           ^   <- счётчик чтения
```
Ещё несколько байт:
```
[ ab ef 03 02 ef  ...]
                     ^   <- счётчик чтения вернул null или EOF (End Of File)
```


Есть некоторые специальные файловые дескрипторы, доступные каждой программе:

- `0 stdin `
- `1 stdout` 
- `2 stderr`

**Учимся выводить:**

Hello world:
```bash
man 2 write  # читаем про системный вызор
```
```asm
    .global main
main:
    .equ SYS_exit, 1
    .equ SYS_write, 4
    .equ STDOUT_FILEND, 1

    mov $SYS_write, %eax
    mov $STDOUT_FILEND, %ebx
    mov $greeting, %ecx  # or lea greeting, ecx
    mov $greetingend-greeting, %edx  # хитренько посчитали количество байт в строке, как разность двух адресов
    # важно, что ставим доллар перед операндом, чтобы указать, что это число, а внутри можно что угодно считать
    int $0x80

    mov $SYS_exit, %eax
    mov $3, %ebx  
    int $0x80 

.greeting:
    .ascii "Hello world!\n"
greetingend:
```

Смотрим через `strace`:
```bash
    strace ./program
```

#### Короткий Q&A

1. *Как расшифровывается `int $0x80 `?* Представим, что на компьютере выполняется одна программа А и одновременно пользователь ввел что-то на компьютере. Если процессор не остановится и не запомнит, какую кнопку нажал пользователь, последний будет недоволен. Поэтому нужно уметь прервать программу А, сохранить ее состояние, записать действие пользователя и дальше продолжить действие программы с того же места (и в случае необходимости использовать введенные данные пользователя). Данные пользователя могут быть любые: мышь, клавиатура, чтение из файла. 

    В текущее время прерывание работает как обращение к ОС. То есть прерываем программу, сохраняем состояние, что-то делаем с ОС и возращаемся к программе. Этим и занимаемся. 

    - Программное прерывание -- иницируется в коде программы

        По договоренности с ОС на ядре Linux номер для системного вызова — это `0x80`

    - Аппаратное прерывание -- как раз от действий пользователя (нажатие на клавиатуре)

2. *Почему мы не общаемся с ОС с помощью `call`?* Если бы мы могли вызвать произвольный кусок кода в ОС, это было бы чревато разного рода ошибками, например, разграничение доступа.

3. *Чем отличается `.edu SYS_exit, 1` и `SYS_exit: .int 1`?* В первом случае мы определяем символ со значением 1, во втором случае мы определяем метку, которая получает значение в виде адреса памяти, куда мы положили 1. Мы используем `.equ`, потому что нам нужна константа 1

4. *Чем отличается `int` от `.int`?*
    1. `int` -- инструкция процессора (в готовом бинарнике, написав `objdump`, мы увидим непосредственно инструкцию, а процессор будет ее исполнять)
    2. `.int` -- директива, которая позволяет нам положить какое-то значение в секцию файла

5. *Так почему нельзя использовать `define`???* Ну можно, но тогда ассемблер будет просто подставлять везде единичку и более корректно выдавать сообщения об ошибках, например.

#### Q&A закончился, учимся дальше выводить и вводить 

**Учимся выводить:**
Хотим вывести ещё один текст (`.prompt`)
```asm
.prompt:
    .ascii "What is your name?\n"
.promptend:
```

Выделим теперь отдельную функцию-обёртку для нашего принта, а то чет много каждый раз писать:

```asm
    .global main

    .equ SYS_exit, 1
    .equ SYS_write, 4
    .equ STDOUT_FILEND, 1

myprint:
    push %ebp
    mov %esp, %ebp

    mov $SYS_write, %eax
    mov $STDOUT_FILEND, %ebx

    mov 8(%ebp), %ecx  # первый параметр  функции -- указатель на начало строки
    mov 12(%ebp), %edx  # второй параметр  функции -- длина строки
   
    int $0x80  # у системных вызовов есть код возврата, он идет в eax

    pop %ebp
    ret

main:
    push $promptend-prompt
    push $prompt  # добавляем параметры, помним, что стек растет вниз
    call myprint
    add $8, %esp  # чистим стек

    mov $SYS_exit, %eax
    mov $3, %ebx  
    int $0x80 

.greeting:
    .ascii "Hello world!\n"
greetingend:

.prompt:
    .ascii "What is your name?\n"
.promptend:
```

**Учимся вводить:**

Напишем функцию, которая будет читать пользовательский ввод в какой-то буфер. Как ни странно, для этого нам нужен буфер — область памяти, в которой мы можем что-то писать.

```asm
    .global main

    .equ SYS_exit, 1
    .equ SYS_read, 3  # read имеет номер 3
    .equ STDIN_FILEND, 0 # поток ввода
    .equ BUFSIZE, 1024  # здесь выделили размер буфера

myinput:
    push %ebp
    mov %esp, %ebp

    mov $SYS_read, %eax
    mov $STDIN_FILEND, %ebx

    mov 8(%ebp), %ecx  # первый параметр  функции -- область памяти откуда читать
    mov 12(%ebp), %edx  # второй параметр  функции -- длина области памяти
   
    int $0x80  # у системных вызовов есть код возврата, он идет в eax

    pop %ebp
    ret  # в этот раз очень интересен возврат

main:
    sub $BUFSIZE, %esp  # выделили место в стеке
    mov %esp, %esi  # скопировали

    push $BUFSIZE
    push %esi
    call myinput
    add $8, %esp

    test %eax, %eax
    # в eax -- возврат
    # если ничего не прочиталось, то в eax -- 0; если ошибка, то eax < 0
    # иначе количество байт, которые прочитали
    jle fail  
```

И теперь дополняем программу, чтобы она и выводила что-то (я тут считаю, что всякие `.equ` и `myinput/myprint` уже реализованы выше и показываю только `main`:
```asm
main:
    push $promptend-prompt
    push $prompt 
    call myprint
    add $8, %esp

    sub $BUFSIZE, %esp  # выделили место в стеке
    mov %esp, %esi  # скопировали

    push $BUFSIZE
    push %esi
    call myinput
    add $8, %esp

    test %eax, %eax
    jle fail  
    mov %eax, %edi

    push $greetingend-greeting
    push $greeting
    call myprint

    mov %esi, (%esp)
    mov %edi, 4(%esp)
    call myprint

    mov $SYS_exit, %eax
    mov $0, %ebx  # В Linux нулевой код возврата -- успешный
    int $0x80 
fail:
    mov $SYS_exit, %eax
    mov $1, %ebx  # В Linux ненулевой код возврата -- неуспешный
    int $0x80 
greeting:
    .ascii "Hello, "
greetingend:
```

Таким образом, ожидается, что при запуске будет следующее:
```
> What's your name?
< Alex
> Hello, Alex
```

Подать на ввод можно так:
```bash
echo hello | ./program
```

#### Пример: шифруем кодом Цезаря

```asm
main:
    sub $BUFSIZE, %esp 
    mov %esp, %esi  # esi -- буфер

readloop:
    push $BUFSIZE
    push %esi
    call myinput
    add $8, %esp

    test %eax, %eax
    jle done  
    mov %eax, %edi

    xor %ecx, %ecx  # счётчик

encrypt:
    mov (%esi, %ecx), %al # загружаем ecx-ный байт буфера в al
    cmp $'a', %al
    jl nextchar
    cmp $'z', %al
    jg nextchar

    add $13, %al # прибавляем 13 к символу
    cmp $'z', %al # если получилось, что больше символа 'z', то вычитаем 26
    jna ok  # jump if above (CF == 1 or ZF == 1)
    sub $26, %al

ok:
    mov %al, (%esi, %ecx)  # сохранили в памяти

nextchar:
    inc %ecx # увеличили ecx
    cmp %ecx, %edi  # сравниваем с длиной буфера, если дошли до конца слова, то заканчиваем
    jnz encrypt

    push %edi
    push %esi
    call myprint
    jmp readloop

done:
    mov $SYS_exit, %eax
    mov $0, %ebx
    int $0x80 

```